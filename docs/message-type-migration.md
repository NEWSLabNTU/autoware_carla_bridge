# Message Type Migration: zenoh-ros-type to rclrs

## Overview

This document describes the migration strategy for replacing `zenoh-ros-type` message definitions with rclrs-provided interface packages from the Autoware workspace.

**Key Change**: Instead of using the standalone `zenoh-ros-type` crate that provides ROS message type definitions, we will use the message types generated by rclrs from the actual Autoware ROS 2 workspace.

## Current Implementation (zenoh-ros-type)

### Dependency Structure

```toml
# Cargo.toml (current)
[dependencies]
zenoh = "1.5.1"
zenoh-ros-type = "0.3.7"
cdr = "0.2.4"
```

### Import Pattern

```rust
// sensor_bridge.rs
use zenoh_ros_type::{geometry_msgs, sensor_msgs, std_msgs};

// vehicle_bridge.rs
use zenoh_ros_type::{
    autoware_vehicle_msgs::{
        control_mode_report, gear_report, hazard_lights_report, turn_indicators_report,
        ControlModeReport, GearCommand, GearReport, HazardLightsReport, SteeringReport,
        TurnIndicatorsReport, VelocityReport,
    },
    builtin_interfaces::Time,
    std_msgs::Header,
    tier4_control_msgs::{gate_mode_data, GateMode},
    tier4_vehicle_msgs::{
        ActuationCommand, ActuationCommandStamped, ActuationStatus, ActuationStatusStamped,
    },
};
```

### Message Usage Pattern

```rust
// Creating a message
let image_msg = sensor_msgs::Image {
    header,
    height: height as u32,
    width: width as u32,
    encoding: "bgra8".to_string(),
    is_bigendian: utils::is_bigendian().into(),
    step: (width * 4) as u32,
    data,
};

// Manual CDR serialization
let encoded = cdr::serialize::<_, _, CdrLe>(&image_msg, Infinite)?;

// Publishing to Zenoh
publisher.put(encoded).wait()?;
```

### Deserialization Pattern

```rust
// Subscribing from Zenoh
let subscriber = z_session
    .declare_subscriber(topic_key)
    .callback_mut(move |sample| {
        // Manual CDR deserialization
        let result: Result<ActuationCommandStamped, _> =
            cdr::deserialize_from(sample.payload().reader(), cdr::size::Infinite);
        let Ok(cmd) = result else {
            log::error!("Unable to parse data");
            return;
        };
        // Use cmd...
    })
    .wait()?;
```

## Target Implementation (rclrs)

### Dependency Structure

```toml
# Cargo.toml (target)
[dependencies]
rclrs = "0.4"
# zenoh, zenoh-ros-type, and cdr dependencies REMOVED
```

### How rclrs Provides Message Types

1. **Build-time generation**: When you source the Autoware workspace and run the first cargo build, rclrs generates `.cargo/config.toml` with paths to all available message packages.

2. **Example .cargo/config.toml** (auto-generated):
```toml
[build]
rustflags = [
    "--cfg", "r2r__sensor_msgs__msg",
    "--cfg", "r2r__geometry_msgs__msg",
    "--cfg", "r2r__std_msgs__msg",
    "--cfg", "r2r__autoware_vehicle_msgs__msg",
    "--cfg", "r2r__tier4_vehicle_msgs__msg",
    # ... more packages
]
```

3. **Message type availability**: rclrs uses the r2r crate internally, which generates Rust bindings from ROS 2 message definitions found in the workspace.

### Import Pattern

```rust
// After migration - standard ROS 2 message imports
use rclrs::QOS_PROFILE_SENSOR_DATA;
use sensor_msgs::msg::{Image, CameraInfo, PointCloud2, Imu, NavSatFix, PointField};
use geometry_msgs::msg::{Quaternion, Vector3};
use std_msgs::msg::Header;

// Autoware-specific messages
use autoware_vehicle_msgs::msg::{
    ControlModeReport, GearCommand, GearReport, HazardLightsReport,
    SteeringReport, TurnIndicatorsReport, VelocityReport,
};
use tier4_vehicle_msgs::msg::{
    ActuationCommand, ActuationCommandStamped,
    ActuationStatus, ActuationStatusStamped,
};
use tier4_control_msgs::msg::GateMode;
use builtin_interfaces::msg::Time;
```

### Message Usage Pattern

```rust
// Creating a message (same struct population)
let image_msg = Image {
    header,
    height: height as u32,
    width: width as u32,
    encoding: "bgra8".to_string(),
    is_bigendian: utils::is_bigendian(),  // Note: no .into() needed
    step: (width * 4) as u32,
    data,
};

// Publishing to ROS 2 (NO manual serialization)
publisher.publish(&image_msg)?;
```

### Subscription Pattern

```rust
// Subscribing from ROS 2
let subscription = node.create_subscription::<ActuationCommandStamped, _>(
    "/control/command/actuation_cmd",
    rclrs::QOS_PROFILE_DEFAULT,
    move |msg: ActuationCommandStamped| {
        // msg is already deserialized!
        // Use msg directly...
    }
)?;
```

## Migration Strategy

### Phase 1: Update Cargo.toml

**Remove:**
```toml
zenoh = "1.5.1"
zenoh-ros-type = "0.3.7"
cdr = "0.2.4"
```

**Add:**
```toml
rclrs = "0.4"
```

**Keep:** (still needed)
```toml
carla = "0.11.1"
nalgebra = "0.32.3"  # For quaternion calculations
interp = "2.1.1"      # For steering interpolation
arc-swap = "1.6.0"    # For atomic updates
atomic_float = "1.1.0"
```

### Phase 2: Update Import Statements

Create a migration table for all files:

| File | Current Import | New Import |
|------|---------------|------------|
| sensor_bridge.rs | `use zenoh_ros_type::{geometry_msgs, sensor_msgs, std_msgs};` | `use sensor_msgs::msg::*;`<br>`use geometry_msgs::msg::*;`<br>`use std_msgs::msg::Header;` |
| vehicle_bridge.rs | `use zenoh_ros_type::autoware_vehicle_msgs::*;` | `use autoware_vehicle_msgs::msg::*;` |
| vehicle_bridge.rs | `use zenoh_ros_type::tier4_vehicle_msgs::*;` | `use tier4_vehicle_msgs::msg::*;` |
| vehicle_bridge.rs | `use zenoh_ros_type::tier4_control_msgs::*;` | `use tier4_control_msgs::msg::*;` |
| clock.rs | `use zenoh_ros_type::rosgraph_msgs;` | `use rosgraph_msgs::msg::Clock;` |

### Phase 3: Message Struct Compatibility

Most message struct definitions remain **identical** between zenoh-ros-type and rclrs. The field names and types match the ROS 2 IDL definitions.

**Example - No changes needed:**
```rust
// Both zenoh-ros-type and rclrs use the same struct definition
let velocity_msg = VelocityReport {
    header,
    longitudinal_velocity: velocity.norm(),
    lateral_velocity: 0.0,
    heading_rate: -wheel_angle.to_radians(),
};
```

**Minor differences to watch for:**

1. **Boolean fields**: Some might change from `u8` to `bool`
   - `is_bigendian: utils::is_bigendian().into()` → `is_bigendian: utils::is_bigendian()`

2. **Constants/Enums**: Access pattern might change
   - Current: `control_mode_report::AUTONOMOUS` (module::constant)
   - Target: May become `ControlModeReport::AUTONOMOUS` (type::constant)
   - Need to verify actual rclrs enum representation

### Phase 4: Remove CDR Serialization/Deserialization

**Before (every publish):**
```rust
let encoded = cdr::serialize::<_, _, CdrLe>(&msg, Infinite)?;
publisher.put(encoded).wait()?;
```

**After (direct publish):**
```rust
publisher.publish(&msg)?;
```

**Before (every subscribe callback):**
```rust
.callback_mut(move |sample| {
    let result: Result<GearCommand, _> =
        cdr::deserialize_from(sample.payload().reader(), cdr::size::Infinite);
    let Ok(cmd) = result else {
        log::error!("Unable to parse data");
        return;
    };
    // Use cmd...
})
```

**After (typed callback):**
```rust
.callback(move |msg: GearCommand| {
    // msg is already deserialized
    // Use msg directly...
})
```

### Phase 5: Update Type Definitions

Some type aliases and constants need updating:

**Current (sensor_bridge.rs:33):**
```rust
use crate::types::{GnssService, GnssStatus, PointFieldType};
```

**Target:** Check if these exist in rclrs-provided packages or need to be defined locally:
- `PointFieldType` → likely `sensor_msgs::msg::PointField::*` constants
- `GnssService`, `GnssStatus` → check `sensor_msgs::msg::NavSatStatus` constants

### Phase 6: Remove Zenoh Attachments

**Current:** Uses attachments for rmw_zenoh compatibility
```rust
let attachment = utils::generate_attachment();
put_with_attachment!(publisher, encoded, attachment, mode)?;
```

**Target:** Not needed with rclrs (native ROS 2)
```rust
publisher.publish(&msg)?;
```

## Message Type Reference

### Complete Message Type Inventory

Based on code review, here are all ROS message types currently used:

#### Standard ROS 2 Messages
- `std_msgs::msg::Header`
- `builtin_interfaces::msg::Time`
- `geometry_msgs::msg::Quaternion`
- `geometry_msgs::msg::Vector3`
- `rosgraph_msgs::msg::Clock`

#### Sensor Messages
- `sensor_msgs::msg::Image`
- `sensor_msgs::msg::CameraInfo`
- `sensor_msgs::msg::RegionOfInterest`
- `sensor_msgs::msg::PointCloud2`
- `sensor_msgs::msg::PointField`
- `sensor_msgs::msg::Imu`
- `sensor_msgs::msg::NavSatFix`
- `sensor_msgs::msg::NavSatStatus`

#### Autoware Vehicle Messages
- `autoware_vehicle_msgs::msg::ControlModeReport`
- `autoware_vehicle_msgs::msg::GearCommand`
- `autoware_vehicle_msgs::msg::GearReport`
- `autoware_vehicle_msgs::msg::HazardLightsReport`
- `autoware_vehicle_msgs::msg::SteeringReport`
- `autoware_vehicle_msgs::msg::TurnIndicatorsReport`
- `autoware_vehicle_msgs::msg::TurnIndicatorsCommand`
- `autoware_vehicle_msgs::msg::HazardLightsCommand`
- `autoware_vehicle_msgs::msg::VelocityReport`

#### Tier4 Messages
- `tier4_vehicle_msgs::msg::ActuationCommand`
- `tier4_vehicle_msgs::msg::ActuationCommandStamped`
- `tier4_vehicle_msgs::msg::ActuationStatus`
- `tier4_vehicle_msgs::msg::ActuationStatusStamped`
- `tier4_control_msgs::msg::GateMode`

### Constants and Enums

Need to verify the exact representation in rclrs for these constants:

**Gear Report** (vehicle_bridge.rs:144, 397-402):
- `gear_report::NONE`
- `gear_report::DRIVE`
- `gear_report::REVERSE`
- `gear_report::PARK`

**Control Mode Report** (vehicle_bridge.rs:307-308):
- `control_mode_report::AUTONOMOUS`
- `control_mode_report::MANUAL`

**Gate Mode** (vehicle_bridge.rs:159):
- `gate_mode_data::AUTO`

**Turn Indicators** (vehicle_bridge.rs:330):
- `turn_indicators_report::DISABLE`

**Hazard Lights** (vehicle_bridge.rs:349):
- `hazard_lights_report::DISABLE`

**Point Field Types** (types.rs, sensor_bridge.rs:553-584):
- `PointFieldType::FLOAT32`
- `PointFieldType::UINT8`
- `PointFieldType::UINT16`

**GNSS Status** (types.rs, sensor_bridge.rs:741-745):
- `GnssStatus::SbasFix`
- `GnssService::Gps`
- `GnssService::Glonass`
- `GnssService::Compass`
- `GnssService::Galileo`

## Testing Strategy

### Step 1: Verify Message Type Availability

After sourcing Autoware environment and first build:

```bash
# Source Autoware workspace
source external/autoware/install/setup.bash

# Verify message packages are available
ros2 interface package sensor_msgs
ros2 interface package autoware_vehicle_msgs
ros2 interface package tier4_vehicle_msgs
ros2 interface package tier4_control_msgs

# Check specific message definitions
ros2 interface show sensor_msgs/msg/Image
ros2 interface show autoware_vehicle_msgs/msg/VelocityReport
ros2 interface show tier4_vehicle_msgs/msg/ActuationCommandStamped

# Build to generate .cargo/config.toml
make build

# Verify generated config
cat .cargo/config.toml
```

### Step 2: Incremental Migration Testing

1. **Test message struct creation** - Verify all fields compile
2. **Test publishing** - Verify messages can be published
3. **Test subscribing** - Verify messages can be received
4. **Test constants** - Verify enum values match expectations
5. **Integration test** - Run full bridge with CARLA

### Step 3: Message Compatibility Verification

Create a test to verify message field compatibility:

```rust
#[test]
fn test_message_compatibility() {
    // Verify Image message structure
    let img = sensor_msgs::msg::Image {
        header: Default::default(),
        height: 480,
        width: 640,
        encoding: "bgra8".to_string(),
        is_bigendian: 0,
        step: 2560,
        data: vec![],
    };
    assert_eq!(img.height, 480);

    // Verify VelocityReport structure
    let vel = autoware_vehicle_msgs::msg::VelocityReport {
        header: Default::default(),
        longitudinal_velocity: 5.0,
        lateral_velocity: 0.0,
        heading_rate: 0.1,
    };
    assert_eq!(vel.longitudinal_velocity, 5.0);

    // Add tests for all message types...
}
```

## Migration Checklist

- [ ] Update Cargo.toml dependencies
- [ ] Source Autoware workspace before building
- [ ] Run initial build to generate .cargo/config.toml
- [ ] Verify .cargo/config.toml contains all needed message packages
- [ ] Update import statements in all bridge files
- [ ] Remove CDR serialization calls
- [ ] Remove CDR deserialization calls
- [ ] Remove Zenoh attachment generation
- [ ] Update constant/enum access patterns
- [ ] Verify message struct field compatibility
- [ ] Update utils.rs to remove CDR-related functions
- [ ] Update types.rs to use rclrs types
- [ ] Test compile all bridge files
- [ ] Test message creation
- [ ] Test publishing
- [ ] Test subscribing
- [ ] Integration test with CARLA

## Benefits of Migration

1. **Type Safety**: Using message types directly from Autoware ensures compatibility
2. **No Manual Serialization**: rclrs handles CDR encoding/decoding automatically
3. **Reduced Dependencies**: Remove zenoh-ros-type and cdr crates
4. **Better IDE Support**: Message types have proper documentation from ROS 2 IDL
5. **Automatic Updates**: Message types stay in sync with Autoware workspace
6. **Standard ROS 2 Patterns**: Follows conventional ROS 2 Rust development practices

## Risks and Mitigations

### Risk 1: Message Field Differences
**Mitigation**: Create comprehensive tests comparing field names and types

### Risk 2: Enum/Constant Representation
**Mitigation**: Document actual constant values from rclrs, create type aliases if needed

### Risk 3: Missing Message Packages
**Mitigation**: Verify all packages are available in Autoware workspace before migration

### Risk 4: Build System Changes
**Mitigation**: Document exact build procedure, ensure Autoware workspace is sourced

## References

- [rclrs documentation](https://github.com/ros2-rust/ros2_rust)
- [r2r message generation](https://github.com/sequenceplanner/r2r)
- [ROS 2 Interface Definition](https://docs.ros.org/en/humble/Concepts/About-ROS-Interfaces.html)
- [Autoware message definitions](https://github.com/autowarefoundation/autoware_msgs)
- Current codebase: `external/zenoh_carla_bridge/src/`
